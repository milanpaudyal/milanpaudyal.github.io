import {
  require_react
} from "./chunk-RUPNRBO7.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// packages/spark-tools/dist/index.js
var import_react = __toESM(require_react());

// packages/spark-tools/dist/kv-DBiZoNWq.js
var KvEventType = {
  SPARK_KV_UPDATED: "sparkKvUpdated",
  SPARK_KV_DELETED: "sparkKvDeleted"
};
var sendEventToWorkbench = (message) => {
  if (import.meta.env.DEV) {
    window.parent.postMessage(message, "*");
  }
};
var KVClient = class {
  /**
  * Retrieves a list of all keys in the KV store.
  * @returns A list of all keys in the KV store, or an empty array if there are no keys.
  */
  async getKeys() {
    const response = await fetch(BASE_KV_SERVICE_URL, {
      method: "GET"
    });
    if (!response.ok) {
      const errorMessage = `Failed to fetch KV keys: ${response.statusText}`;
      return Promise.reject(new Error(errorMessage));
    }
    let json;
    try {
      json = await response.json();
    } catch (error) {
      const errorMessage = "Failed to parse KV keys response";
      return Promise.reject(new Error(errorMessage));
    }
    if (!Array.isArray(json)) {
      const errorMessage = "KV keys response is not an array";
      return Promise.reject(new Error(errorMessage));
    }
    return json;
  }
  /**
   * Retrieves all key-value pairs from the KV store.
   * @returns An object containing all key-value pairs, or an empty object if there are no keys.
   *
   * TODO: replace with batch request
   */
  async getAll() {
    const keys = await this.getKeys();
    const result = {};
    const values = await Promise.all(keys.map((key) => this.getKey(key)));
    keys.forEach((key, index) => {
      const value = values[index];
      if (value !== void 0) {
        result[key] = value;
      }
    });
    return result;
  }
  /**
   * Retrieves the value associated with the given key from the KV store.
   * @param key The key to retrieve.
   * @param collectionName Optional collection name to include as a URL parameter.
   * @returns The value associated with the key, or undefined if not found.
   */
  async getKey(key, collectionName) {
    let url = `${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`;
    if (collectionName) {
      url += `?collection=${encodeURIComponent(collectionName)}`;
    }
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": `text/plain`
      }
    });
    if (!response.ok) {
      const errorMessage = `Failed to fetch KV key: ${response.statusText}`;
      if (response.status === 404) {
        return void 0;
      }
      return Promise.reject(new Error(errorMessage));
    }
    const responseText = await response.text();
    try {
      return JSON.parse(responseText);
    } catch (error) {
      const errorMessage = `Failed to parse KV key response`;
      return Promise.reject(new Error(errorMessage));
    }
  }
  /**
   * Retrieves the value associated with the given key from the KV store, while also setting it if it does not exist.
   * @param key The key to retrieve.
   * @param value The value to set if the key does not exist.
   * @returns The value associated with the key, whether it was retrieved or newly set.
   */
  async getOrSetKey(key, value) {
    const existingValue = await this.getKey(key);
    if (existingValue !== void 0) {
      return existingValue;
    }
    const response = await fetch(`${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`, {
      method: "POST",
      headers: {
        "Content-Type": `text/plain`,
        "X-Spark-Initial": "true"
      },
      body: JSON.stringify(value)
    });
    if (!response.ok) {
      const errorMessage = `Failed to set default value for key: ${response.statusText}`;
      return Promise.reject(new Error(errorMessage));
    }
    sendEventToWorkbench({
      type: KvEventType.SPARK_KV_UPDATED,
      payload: { key }
    });
    return value;
  }
  /**
   * Sets the value for the given key in the KV store.
   * @param key The key to set.
   * @param value The value to associate with the key.
   * @param collectionName Optional collection name to include as a URL parameter.
   * @returns A promise that resolves when the operation is complete.
   */
  async setKey(key, value, collectionName) {
    let url = `${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`;
    if (collectionName) {
      url += `?collection=${encodeURIComponent(collectionName)}`;
    }
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": `text/plain`,
        "X-Spark-Initial": "false"
      },
      body: JSON.stringify(value)
    });
    if (!response.ok) {
      const errorMessage = `Failed to set key: ${response.statusText}`;
      return Promise.reject(new Error(errorMessage));
    }
    sendEventToWorkbench({
      type: KvEventType.SPARK_KV_UPDATED,
      payload: { key, value: JSON.stringify(value) }
    });
  }
  /**
   * Deletes the value associated with the given key from the KV store.
   * @param key The key to delete from the KV store.
   * @param collectionName Optional collection name to include as a URL parameter.
   */
  async deleteKey(key, collectionName) {
    let url = `${BASE_KV_SERVICE_URL}/${encodeURIComponent(key)}`;
    if (collectionName) {
      url += `?collection=${encodeURIComponent(collectionName)}`;
    }
    await fetch(url, { method: "DELETE" });
    sendEventToWorkbench({
      type: KvEventType.SPARK_KV_DELETED,
      payload: { key }
    });
  }
};

// packages/spark-tools/dist/index.js
function useKV(key, initialValue) {
  const [value, setValue] = (0, import_react.useState)(initialValue);
  const kvClient = (0, import_react.useMemo)(() => {
    return new KVClient();
  }, []);
  const handleMessage = (0, import_react.useCallback)(async (event) => {
    switch (event.data.type) {
      case KvEventType.SPARK_KV_DELETED:
        if (event.data.payload.key === key) {
          setValue(void 0);
        }
        return;
      case KvEventType.SPARK_KV_UPDATED:
        if (event.data.payload.key === key) {
          setValue(await kvClient.getKey(key));
        }
        return;
    }
  }, [key]);
  (0, import_react.useEffect)(() => {
    if (!import.meta.env.DEV) {
      return;
    }
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, [key, handleMessage]);
  (0, import_react.useEffect)(() => {
    async function getOrSetKey() {
      setValue(await kvClient.getOrSetKey(key, initialValue));
    }
    getOrSetKey();
  }, [kvClient]);
  const deleteValue = (0, import_react.useCallback)(() => {
    kvClient.deleteKey(key);
    setValue(void 0);
  }, [key]);
  const userSetValue = (0, import_react.useCallback)((newValue) => {
    setValue((currentValue) => {
      const nextValue = typeof newValue === "function" ? newValue(currentValue) : newValue;
      kvClient.setKey(key, nextValue);
      return nextValue;
    });
  }, [key, kvClient]);
  return [value, userSetValue, deleteValue];
}
export {
  useKV
};
//# sourceMappingURL=@github_spark_hooks.js.map
